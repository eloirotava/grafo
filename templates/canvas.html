{% extends "layout.html" %}

{% block content %}
<style>
    /* Layout */
    .editor-layout { display: flex; flex-grow: 1; height: 100%; overflow: hidden; }
    
    /* Sidebar */
    .sidebar { width: 150px; background-color: #252526; color: #ccc; display: flex; flex-direction: column; align-items: center; padding-top: 15px; border-right: 1px solid #3e3e42; overflow-y: auto; user-select: none; }
    .palette-group { width: 100%; text-align: center; margin-bottom: 20px; }
    .group-title { font-size: 11px; text-transform: uppercase; color: #858585; margin-bottom: 10px; font-weight: bold; }
    
    .palette-item { width: 120px; height: 70px; background-color: #333; margin: 0 auto 10px auto; border: 1px solid #3e3e42; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: grab; transition: all 0.2s; }
    .palette-item:hover { background-color: #3e3e42; border-color: #007acc; transform: translateY(-2px); }
    .palette-item span { margin-top: 6px; font-size: 12px; }

    /* Ícones Geométricos Limpos */
    .icon-node { width: 12px; height: 12px; border-radius: 50%; background: #3498db; border: 2px solid #fff; }
    .icon-mono { width: 24px; height: 24px; border-radius: 50%; background: #1abc9c; border: 2px solid #fff; } /* Verde Água */
    .icon-double { width: 30px; height: 18px; background: #e67e22; border: 2px solid #fff; border-radius: 2px; }
    .icon-tri { width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 20px solid #f1c40f; }
    .icon-quad { width: 20px; height: 20px; background: #9b59b6; border: 2px solid #fff; }
    .icon-arrow { width: 26px; height: 2px; background: #fff; position: relative; }
    .icon-arrow::after { content:''; position: absolute; right: -2px; top: -3px; border-left: 5px solid #fff; border-top: 4px solid transparent; border-bottom: 4px solid transparent; }

    /* Área do Canvas */
    .canvas-area { flex-grow: 1; background-color: #1e1e1e; position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden; }
    canvas { display: block; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    .statusbar { position: absolute; bottom: 0; left: 0; right: 0; height: 22px; background-color: #007acc; color: white; display: flex; align-items: center; padding: 0 10px; font-size: 11px; pointer-events: none; z-index: 999; }
</style>

<div class="editor-layout">
    <div class="sidebar">
        <div class="palette-group">
            <div class="group-title">Junções</div>
            <div class="palette-item" draggable="true" ondragstart="drag(event, 'node')"><div class="icon-node"></div><span>Nó (Ponto)</span></div>
        </div>
        <div class="palette-group">
            <div class="group-title">Equipamentos</div>
            <div class="palette-item" draggable="true" ondragstart="drag(event, 'mono')"><div class="icon-mono"></div><span>Mono (1)</span></div>
            <div class="palette-item" draggable="true" ondragstart="drag(event, 'double')"><div class="icon-double"></div><span>Duplo (2)</span></div>
            <div class="palette-item" draggable="true" ondragstart="drag(event, 'triangle')"><div class="icon-tri"></div><span>Triplo (3)</span></div>
            <div class="palette-item" draggable="true" ondragstart="drag(event, 'square')"><div class="icon-quad"></div><span>Quádruplo (4)</span></div>
        </div>
        <div class="palette-group">
            <div class="group-title">Conexões</div>
            <div class="palette-item" draggable="true" ondragstart="drag(event, 'duct')"><div class="icon-arrow"></div><span>Duto</span></div>
        </div>
    </div>
    
    <div class="canvas-area" id="wrap">
        <canvas id="c"></canvas>
        <div class="statusbar" id="status-msg">Pronto. Arraste itens para o canvas.</div>
    </div>
</div>

<script>
    const canvas = new fabric.Canvas('c', { selection: true, preserveObjectStacking: true, backgroundColor: '#ffffff' });
    let nodeSeq = 1, ductSeq = 1;
    function setStatus(m) { document.getElementById('status-msg').innerText = m; }

    // --- Redimensionamento ---
    function resize() {
        const w = document.getElementById('wrap');
        canvas.setWidth(w.clientWidth - 40); canvas.setHeight(w.clientHeight - 40); canvas.renderAll();
    }
    window.addEventListener('resize', resize); setTimeout(resize, 100);

    // --- Drag & Drop ---
    window.drag = (e, t) => { e.dataTransfer.setData("type", t); };
    const wrap = document.getElementById('wrap');
    wrap.ondragover = e => { e.preventDefault(); return false; };
    wrap.ondrop = e => {
        e.preventDefault();
        const type = e.dataTransfer.getData("type");
        const rect = canvas.getElement().getBoundingClientRect();
        const x = e.clientX - rect.left; const y = e.clientY - rect.top;
        if(type==='duct') createDuct(x,y); else createEq(x,y,type);
    };

    // --- CRIAÇÃO DE EQUIPAMENTOS ---
    function createEq(x, y, type, loadId=null, loadName=null) {
        let prefix = 'E';
        if(type==='node') prefix='N'; if(type==='mono') prefix='M'; if(type==='double') prefix='D'; if(type==='triangle') prefix='T'; if(type==='square') prefix='Q';
        
        const id = loadId || (prefix + nodeSeq++);
        const name = loadName || id;
        const objs = [];
        const addPort = (lx, ly, pid) => { objs.push(new fabric.Circle({radius:3, fill:'#333', left:lx, top:ly, originX:'center', originY:'center', portId:pid, stroke:'#fff', strokeWidth:1})); };

        if (type === 'node') {
            objs.push(new fabric.Circle({radius:8, fill:'#3498db', stroke:'#2980b9', strokeWidth:2, originX:'center', originY:'center'}));
            addPort(0,0,0); // Porta Central
        } else if (type === 'mono') { // Fonte/Reservatório
            objs.push(new fabric.Circle({radius:20, fill:'#1abc9c', stroke:'#16a085', strokeWidth:2, originX:'center', originY:'center'}));
            addPort(0, 20, 1); // 1 Porta em baixo
        } else if (type === 'double') {
            objs.push(new fabric.Rect({width:50, height:30, fill:'#e67e22', stroke:'#d35400', strokeWidth:2, rx:4, ry:4, originX:'center', originY:'center'}));
            addPort(-25, 0, 1); addPort(25, 0, 2);
        } else if (type === 'triangle') {
            objs.push(new fabric.Triangle({width:44, height:40, fill:'#f1c40f', stroke:'#f39c12', strokeWidth:2, originX:'center', originY:'center'}));
            addPort(0, -20, 3); addPort(-22, 20, 1); addPort(22, 20, 2);
        } else if (type === 'square') {
            objs.push(new fabric.Rect({width:40, height:40, fill:'#9b59b6', stroke:'#8e44ad', strokeWidth:2, originX:'center', originY:'center'}));
            addPort(-20, -20, 1); addPort(20, -20, 2); addPort(20, 20, 3); addPort(-20, 20, 4);
        }

        const label = new fabric.Text(name, {fontSize:12, fill:'#333', top:(type==='node'?15:28), originX:'center', originY:'center', fontWeight:'600', fontFamily:'Segoe UI'});
        objs.push(label);

        const group = new fabric.Group(objs, {left:x, top:y, subTargetCheck:true, hasControls:false, hasBorders:false});
        group.data = {type:'equipment', subType:type, id:id, name:name, labelObj:label};
        
        group.on('moving', () => updateLines(group));
        canvas.add(group); canvas.sendToBack(group); // NÓ NO FUNDO
        setStatus(`Criado: ${name}`);
        return group;
    }

    // --- CRIAÇÃO DE DUTOS ---
    function createDuct(x, y, loadId=null, loadName=null) {
        const id = loadId || ('L' + ductSeq++);
        const name = loadName || id;
        const p1 = new fabric.Circle({radius:5, fill:'#e74c3c', left:x-40, top:y, originX:'center', originY:'center', hasControls:false, hasBorders:false});
        const p2 = new fabric.Circle({radius:5, fill:'#e74c3c', left:x+40, top:y, originX:'center', originY:'center', hasControls:false, hasBorders:false});
        const line = new fabric.Line([x-40,y,x+40,y], {stroke:'#555', strokeWidth:3, selectable:true, hasControls:false, hasBorders:false, originX:'center', originY:'center'});
        const head = new fabric.Triangle({width:10, height:10, fill:'#555', originX:'center', originY:'center', selectable:false});
        const label = new fabric.Text(name, {fontSize:11, fill:'#e67e22', backgroundColor:'#fff', originX:'center', originY:'center', selectable:false, evented:true});

        const data = {type:'duct', id, name, p1, p2, line, head, label};
        line.data=head.data=label.data=data; p1.data=p2.data={isAnchor:true, parent:data};

        const update = () => {
            line.set({x1:p1.left, y1:p1.top, x2:p2.left, y2:p2.top}); line._setWidthHeight();
            const angle = Math.atan2(p2.top-p1.top, p2.left-p1.left) * 180 / Math.PI;
            head.set({left:p2.left, top:p2.top, angle:angle+90});
            label.set({left:(p1.left+p2.left)/2, top:(p1.top+p2.top)/2 - 15});
            canvas.renderAll();
        };

        line.on('mousedown', function(){this.lastLeft=this.left; this.lastTop=this.top});
        line.on('moving', function(){
            const dx=this.left-this.lastLeft, dy=this.top-this.lastTop;
            p1.set({left:p1.left+dx, top:p1.top+dy}).setCoords(); p2.set({left:p2.left+dx, top:p2.top+dy}).setCoords();
            this.lastLeft=this.left; this.lastTop=this.top; update();
        });
        [p1,p2].forEach(p => {
            p.on('moving', update);
            p.on('modified', () => { checkSnap(p); update(); });
        });

        canvas.add(line, head, label, p1, p2); p1.bringToFront(); p2.bringToFront();
        update();
        return line;
    }

    // --- SNAP LÓGICA ---
    function isOccupied(nodeId, portId, selfId) {
        return canvas.getObjects('line').some(l => {
            if(!l.data || l.data.id === selfId) return false;
            const d = l.data;
            return (d.p1.data.linkedNode===nodeId && d.p1.data.linkedPort===portId) || (d.p2.data.linkedNode===nodeId && d.p2.data.linkedPort===portId);
        });
    }

    function checkSnap(anchor) {
        anchor.set({fill:'#e74c3c'}); anchor.data.linkedNode=null; anchor.data.linkedPort=0;
        let snapped = false;
        canvas.getObjects('group').forEach(g => {
            if(snapped || !g.data || g.data.type!=='equipment') return;
            const m = g.calcTransformMatrix();
            g.getObjects().forEach(o => {
                if(o.portId===undefined) return;
                const gp = fabric.util.transformPoint(new fabric.Point(o.left, o.top), m);
                if(Math.hypot(anchor.left-gp.x, anchor.top-gp.y) < 20) {
                    if(g.data.subType !== 'node' && isOccupied(g.data.id, o.portId, anchor.data.parent.id)) {
                        setStatus("Porta Ocupada!"); return;
                    }
                    anchor.set({left:gp.x, top:gp.y, fill:'#27ae60'}); anchor.setCoords();
                    anchor.data.linkedNode=g.data.id; anchor.data.linkedPort=o.portId;
                    snapped=true; anchor.bringToFront();
                    setStatus(`Conectado a ${g.data.name}`);
                }
            });
        });
    }

    function updateLines(g) {
        const m = g.calcTransformMatrix();
        const ports = {}; g.getObjects().forEach(o=>{if(o.portId!==undefined) ports[o.portId]=fabric.util.transformPoint(new fabric.Point(o.left,o.top),m);});
        canvas.getObjects('circle').forEach(p => {
            if(p.data?.isAnchor && p.data.linkedNode===g.data.id) {
                const pos = ports[p.data.linkedPort||0];
                if(pos) { p.set({left:pos.x, top:pos.y}).setCoords(); p.data.parent.line.set({x1:p.left}); canvas.renderAll(); } // trigger visual
                const d = p.data.parent; d.line.set({x1:d.p1.left, y1:d.p1.top, x2:d.p2.left, y2:d.p2.top}); // force re-calc
                const angle = Math.atan2(d.p2.top-d.p1.top, d.p2.left-d.p1.left) * 180 / Math.PI;
                d.head.set({left:d.p2.left, top:d.p2.top, angle:angle+90});
                d.label.set({left:(d.p1.left+d.p2.left)/2, top:(d.p1.top+d.p2.top)/2-15});
            }
        });
    }

    // --- PERSISTÊNCIA ---
    function getModel() {
        const nodes = canvas.getObjects('group').map(o=>({id:o.data.id, name:o.data.name, type:o.data.subType, x:o.left, y:o.top}));
        const ducts = canvas.getObjects('line').map(l=>({
            id:l.data.id, name:l.data.name, 
            start_id:l.data.p1.data.linkedNode, end_id:l.data.p2.data.linkedNode,
            start_port:l.data.p1.data.linkedPort||0, end_port:l.data.p2.data.linkedPort||0
        }));
        return {nodes, ducts};
    }

    // Funções Globais (chamadas pelo layout.html)
    window.saveLocal = function() {
        const blob = new Blob([JSON.stringify(getModel(), null, 2)], {type: "application/json"});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `malha_${Date.now()}.json`;
        a.click();
    };

    window.saveToPython = async function() {
        setStatus("Salvando...");
        await fetch('/api/mesh-db', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(getModel())});
        setStatus("Salvo no Servidor."); alert("Salvo!");
    };

    window.loadLocal = function(e) {
        const r = new FileReader();
        r.onload = ev => { reconstruct(JSON.parse(ev.target.result)); e.target.value=''; };
        if(e.target.files[0]) r.readAsText(e.target.files[0]);
    };

    // Recarregar do Servidor ao abrir
    fetch('/api/get-mesh').then(r=>r.json()).then(reconstruct);

    function reconstruct(data) {
        canvas.clear(); canvas.setBackgroundColor('#fff');
        let maxN=0, maxD=0;
        
        data.nodes.forEach(n => {
            const num = parseInt(n.id.replace(/\D/g, ''))||0; if(num>maxN) maxN=num;
            createEq(n.x, n.y, n.type, n.id, n.name);
        });

        data.ducts.forEach(d => {
            const num = parseInt(d.id.replace(/\D/g, ''))||0; if(num>maxD) maxD=num;
            const l = createDuct(0,0,d.id,d.name);
            const link = (p, nid, pid) => {
                if(!nid) return;
                const g = canvas.getObjects('group').find(x=>x.data.id===nid);
                if(g) {
                    const m = g.calcTransformMatrix();
                    const port = g.getObjects().find(o=>o.portId===pid);
                    if(port) {
                        const gp = fabric.util.transformPoint(new fabric.Point(port.left,port.top), m);
                        p.set({left:gp.x, top:gp.y, fill:'#27ae60'}); p.data.linkedNode=nid; p.data.linkedPort=pid;
                    }
                }
            };
            link(l.data.p1, d.start_id, d.start_port);
            link(l.data.p2, d.end_id, d.end_port);
            // Trigger visual update
            const p1=l.data.p1, p2=l.data.p2; 
            l.set({x1:p1.left, y1:p1.top, x2:p2.left, y2:p2.top}); l.setCoords();
            const angle = Math.atan2(p2.top-p1.top, p2.left-p1.left) * 180 / Math.PI;
            l.data.head.set({left:p2.left, top:p2.top, angle:angle+90});
            l.data.label.set({left:(p1.left+p2.left)/2, top:(p1.top+p2.top)/2-15});
        });
        nodeSeq=maxN+1; ductSeq=maxD+1; canvas.renderAll();
    }
    
    // Duplo clique
    canvas.on('mouse:dblclick', e => {
        if(!e.target) return;
        const t = e.target.group || e.target;
        if(t.data) {
            const n = prompt("Renomear:", t.data.name);
            if(n) { t.data.name=n; (t.data.labelObj||t.data.label).set({text:n}); canvas.renderAll(); }
        }
    });
</script>
{% endblock %}